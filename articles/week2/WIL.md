소프트웨어의 모듈 독립성
소프트웨어 개발할 때 문제를 한 번에 다 풀기보단, 작은 단위로 쪼개서 하나씩 해결하는 게 낫다.
이렇게 기능 단위로 나누는 걸 모듈화라고 한다.
모듈은 함수, 클래스, 파일처럼 따로 컴파일 가능한 단위를 말한다.
그리고 소프트웨어가 잘 만들어졌다는 건, 모듈 간의 독립성이 높다는 뜻이기도 하다.
독립성이 높으면 재사용하기 좋고, 코드 이해나 유지보수도 훨씬 쉬워진다.
에러가 나도 기능별로 나뉘어 있으니까 어디서 문제났는지도 금방 찾을 수 있다.
이 독립성은 두 가지 기준으로 판단한다:
•	결합도: 모듈끼리 얼마나 엮여 있는지 → 낮을수록 좋다
•	응집도: 하나의 모듈 안에서 얼마나 관련된 일만 하는지 → 높을수록 좋다

결합도 (Coupling)
결합도는 모듈 간 의존 정도를 말한다.
결합도가 높다는 건 모듈들이 서로 너무 많이 알고 있다는 뜻이고, 하나를 바꾸면 줄줄이 영향을 미친다.
그래서 유지보수가 어렵고 위험 부담도 크다.
반대로 결합도가 낮으면 모듈들이 독립적으로 동작하니까 수정해도 다른 데 영향이 거의 없다.
객체지향에서는 이런 걸 위해 인터페이스 같은 걸로 딱 필요한 정보만 주고받도록 설계한다.
결합도는 종류별로 나뉘는데, 아래로 갈수록 안 좋다.
•	자료 결합도: 그냥 데이터만 주고받는다. 가장 이상적인 형태
•	내용 결합도: 다른 모듈 내부 변수나 로직까지 직접 참조한다. 최악이다

응집도 (Cohesion)
응집도는 하나의 모듈 안에서 기능들이 얼마나 밀접하게 관련되어 있는지를 말한다.
응집도가 높다는 건 그 모듈이 딱 하나의 일만 잘 하고 있다는 뜻이다.
이런 구조는 이해도 쉽고, 수정도 편하고, 재사용도 쉽다.
반면에 응집도가 낮으면 관련 없는 기능들이 섞여 있어서 코드가 산만하고 유지보수가 어렵다.
응집도도 단계가 나뉘는데, 아래로 갈수록 안 좋은 구조다.
•	기능적 응집도: 단일 목적 수행. 최고다
•	우연적 응집도: 관련 없는 기능이 한 모듈에 섞여 있다. 최악이다
높은 응집도와 낮은 결합도의 중요성
결합도가 높으면 클래스가 덩치가 커지고, 수정할 때 어디까지 영향을 미칠지 예측이 안 된다.
응집도가 낮으면 뭐 하는 클래스인지 애매하고, 재사용도 안 되고, 유지보수도 어렵다.
그래서 좋은 소프트웨어는 높은 응집도와 낮은 결합도를 갖춘 모듈 구조를 가진다.
이걸 잘 하기 위한 방법이 객체지향 원칙이나 디자인 패턴들이고,
이 원칙들을 잘 지키다 보면 자연스럽게 좋은 구조가 만들어진다.

HTTP 상태 코드 정리
HTTP 상태 코드는 클라이언트가 서버에 요청을 보냈을 때, 그 요청이 성공했는지 실패했는지를 서버가 숫자로 알려주는 거다.
개발자 도구에서 네트워크 탭 열어보면 Status에 숫자 코드가 뜨는데, 이걸 보면 요청이 잘 됐는지 아닌지 바로 알 수 있다. 물론 숫자만 보고 다 이해하려면 코드별 의미는 따로 외워야 한다.
HTTP 상태 코드는 3자리 숫자로 돼 있고, 첫 숫자 기준으로 아래처럼 5가지 그룹으로 나뉜다.
•	1XX: 요청은 받았고 지금 처리 중이라는 뜻
•	2XX: 요청이 정상적으로 처리됐다는 뜻
•	3XX: 뭔가 추가로 행동이 필요하다는 뜻 (리다이렉트 같은 거)
•	4XX: 클라이언트 쪽 문제. 문법 잘못됐거나 요청이 이상한 경우
•	5XX: 서버 쪽 문제. 서버가 요청을 처리 못하는 상황
그리고 뒷자리 숫자는 비슷한 그룹 안에서도 동작 방식이나 원인이 달라서 구분해 놓은 거다.
예를 들어서 403이랑 404 둘 다 4XX지만, 403은 접근 금지고 404는 페이지 자체가 없는 거다.
그리고 중요한 게 하나 있다. 상태 코드가 의미는 정해져 있긴 한데, 실제 서비스에서는 약속에 따라 다르게 쓸 수도 있다.
예를 들어 200은 성공이라는 뜻이지만, 어떤 API에서는 "계속 진행해도 된다"는 식으로 응용해서 쓰는 경우도 있다. 그래서 무조건 하나의 정답이 있는 건 아니다.
또 사람들이 잘 오해하는 게, 2XX라고 해서 200부터 299까지 전부 다 쓰이는 건 아니라는 거다.
실제로 쓰는 건 몇 개 안 되고, 나머지는 정의만 돼 있거나 아예 비워져 있는 것도 많다.
그래도 클라이언트 입장에서는 맨 앞 숫자만 보고 대충 어떤 종류의 응답인지는 판단할 수 있으니까, 큰 문제는 안 된다.
그리고 앞으로 새로운 상태 코드가 생기더라도 기존 1XX~5XX 범위 안에서만 나오기 때문에 구조가 크게 바뀔 일은 없다.

stateful vs stateless 차이
웹 공부하다 보면 클라이언트랑 서버가 통신할 때 상태를 유지하냐 안 하냐, 그러니까 stateful이냐 stateless냐 이 얘기를 꼭 듣게 된다.
처음엔 '상태를 유지한다는 게 뭐지?' 싶지만, 한 번 이해하고 나면 어렵지 않다.
이번엔 그냥 외워서 넘기는 게 아니라 진짜 제대로 이해하고 넘어가보자.

stateful (상태 유지)
stateful은 서버가 클라이언트의 상태를 기억하고 있는 구조다.
예를 들어 내가 로그인한 상태에서 다른 페이지로 이동해도 로그인이 풀리지 않는 이유가 바로 서버가 내 상태를 기억하고 있기 때문이다.
이런 상태 정보는 브라우저 쿠키나 서버 세션 메모리에 저장되기도 한다.
쉽게 말해서 서버가 '이 사용자는 로그인한 상태야'라는 걸 기억하고 있는 거다.
대표적인 예로 tcp가 있다.
tcp는 3-way handshake라고 해서 syn, syn/ack, ack 주고받으면서 연결 상태를 만들고,
established 상태가 된 다음에 데이터를 주고받는다.
이런 식으로 상태에 따라 응답이 달라지는 구조라서 stateful이라고 한다.

stateful의 단점
서버가 상태를 기억하고 있다는 게 편할 때도 있지만 문제도 생긴다.
예를 들어 내가 로그인했는데 그 상태를 들고 있던 서버가 죽어버리면,
다른 서버가 대신 받더라도 상태 정보가 없으니까 다시 로그인하라고 뜬다.
그리고 서버가 모든 클라이언트 상태를 들고 있어야 하니까 메모리 부담도 크고,
처리 가능한 클라이언트 수도 한정적이다.
예를 들어 한 서버가 최대 1만 명까지 처리 가능한데 2만 명이 몰리면
기존 연결된 사람 중 일부가 끊겨야 다음 요청을 처리할 수 있는 구조다.
그래서 실제 서비스에서는 redis 같은 캐시 서버에 상태 정보를 따로 저장해서
다른 서버가 이어받아도 문제없이 처리할 수 있도록 하기도 한다.

stateful 예시
클라이언트 a가 서버 x한테 cpu 선택 → 그래픽카드 선택 → 케이스 선택
이런 식으로 부품을 고르면서 요청하면, 서버 x는 그 선택 과정을 기억하고 있다가
마지막에 '이거 주문할래요?' 하면 바로 처리해준다.
근데 중간에 서버 x가 죽고 서버 y가 응답하게 되면? 이전 선택 내역을 모른다.
누구세요? 부터 다시 시작하는 상황이 된다.
이게 상태 유지 방식의 한계다.

stateless (무상태)
stateless는 서버가 클라이언트 상태를 전혀 기억하지 않는 구조다.
요청 오면 그냥 받고 처리하고 끝. 다음에 또 오면 또 새롭게 받아들인다.
서버는 이전 요청이 뭐였는지 전혀 모른다.
클라이언트가 자기 상태를 들고 있어야 한다.
요청할 때마다 필요한 정보를 같이 실어 보내는 방식이다.
서버는 그냥 응답만 해주면 되니까 부담도 적고,
서버가 바뀌어도 상관없어서 확장성이 좋다.
http나 udp가 대표적인 예다.
udp는 연결도 없이 그냥 막 보내버리고, http는 요청하고 응답하면 연결을 끊는다.

stateless의 장점
서버가 상태를 안 들고 있으니까 부담이 확 줄어든다.
서버가 죽든 바뀌든 클라이언트가 정보만 잘 넘기면 처리가 된다.
그래서 트래픽이 몰려도 서버 확장이 유연하게 가능하다.
요즘 rest api 같은 것도 다 이런 구조를 따른다.
매 요청마다 클라이언트가 필요한 걸 다 넘기고, 서버는 처리만 한다.

stateless의 단점
단점은 요청할 때마다 정보를 계속 보내야 한다는 점이다.
로그인한 상태를 유지하려면 매번 '나 로그인 했어'라는 정보를 같이 보내야 한다.
그래서 stateless 구조에서는 jwt 같은 토큰 기반 인증 방식을 많이 쓴다.
로그인하면 서버가 토큰 하나 발급해주고,
클라이언트는 그걸 들고 있다가 요청할 때마다 같이 보내서 인증하는 방식이다.
서버는 그걸 보고 '아 얘 로그인했네' 하고 처리하면 된다.
상태 기억 안 해도 되니까 부담이 없다.

서버리스 아키텍처란?
서버리스(serverless)라는 말만 들으면 '서버가 없는 건가?' 싶을 수도 있는데, 실제로 서버가 없는 건 아니고, 서버는 있지만 우리가 직접 관리할 필요가 없는 구조를 말한다.
정확히 말하자면, 서버리스는 백엔드를 직접 구축하거나 관리하지 않아도 되는 아키텍처를 의미한다.
보통 사이드 프로젝트나 프로토타입을 빠르게 만들 때, 이 서버리스 구조를 쓰면 정말 편하다고한다.
비용도 훨씬 저렴하게 들고, 제품을 빠르게 내놓을 수 있어서이다.

서버리스의 탄생 배경
과거에는 어떻게 앱이나 웹서비스를 배포했는지를 보면, 왜 서버리스가 나왔고, 왜 인기 있는지도 이해할 수 있다.
1. 온프레미스 (On-Premise)
예전에는 서버를 직접 설치해서 썼다.
집에 컴퓨터 들여놓고 직접 전원 켜고, 운영체제 설치하고, 서버 코드 올려서 돌리는 식이었다.
그런데 정전이라도 되면 서버 꺼지고, 트래픽 늘면 메모리 사서 직접 업그레이드해야 하고…
개발자 입장에서 너무 번거롭고 귀찮은 일이 많았다.
2. 클라우드 (IaaS / PaaS)
그러다 클라우드가 등장했다.
아마존에서 AWS EC2 같은 걸 내놓으면서, 하드웨어는 이제 빌려쓰면 됐고
정전이나 사고 걱정 없이 서버를 사용할 수 있게 됐다.
하지만 여전히 소프트웨어 부분은 직접 관리해야 했다.
운영체제 업데이트, 백업, 보안 설정 같은 걸 직접 해줘야 하고
무엇보다 유저가 많든 적든 미리 구매한 용량 기준으로 비용을 내야 했다.
즉, 유저가 없어도 서버는 돌아가고 있으니 돈은 계속 나간다는 얘기다.
이런 비효율을 해결하기 위해 서버리스가 등장했다.

3. 서버리스
서버리스는 클라우드 업체가 함수 실행에 필요한 자원만 잠깐 할당해서 처리하고,
그만큼만 돈을 받는 구조다.
대표적인 예가 AWS Lambda다.
예를 들어, 어떤 기능을 서버리스에 올려두면 평소엔 아무것도 안 하고 있다가
요청이 오면 그때 잠깐 깨어나서 함수 실행하고 다시 잠든다.
실행된 횟수만큼만 비용이 발생한다.
예전처럼 서버 한 대 통째로 켜둘 필요가 없고, 사용한 만큼만 돈을 내면 되니까 훨씬 효율적이다.
스케일링도 자동으로 되니까 유저가 갑자기 늘어나도 문제없이 잘 돌아간다.

서버리스 모델: BaaS vs FaaS
BaaS (Backend as a Service)
BaaS는 백엔드 기능 자체를 클라우드에서 API로 제공해주는 모델이다.
데이터 저장, 로그인, 메시지 전송, 소셜 로그인 같은 기능을
API 몇 줄로 바로 쓸 수 있게 해준다.
대표적으로 Firebase 같은 게 있다.
실시간 데이터베이스도 코드 몇 줄이면 되고, 따로 서버 코딩 안 해도 된다.
유저가 늘어나면 자동으로 확장도 해준다.
개발 시간 줄고, 인프라 신경 안 써도 돼서 진짜 편하다.
FaaS (Function as a Service)
FaaS는 우리가 만든 함수를 클라우드에 올려두고
필요할 때 HTTP 요청으로 호출해서 실행시키는 방식이다.
Rest API 요청이 들어오면 함수가 실행되고, 끝나면 꺼진다.
실행 횟수와 시간 기준으로 요금이 나가고, 안 쓰면 돈도 안 나간다.
대표적인 서비스로는 AWS Lambda, Azure Functions, Google Cloud Functions가 있다.
핵심은 백엔드를 함수 단위로 쪼개서 관리할 수 있다는 거다.

객체지향이란 말 그대로 '객체를 중심으로 한다'는 의미다. 
여기서 객체는 어떤 기능을 독립적으로 수행할 수 있는 단위로, 스스로 역할을 수행하는 존재라고 볼 수 있다. 
예를 들어, 프로젝트에서 재고를 관리하는 창고, 주문을 담는 장바구니는 각각 독립적인 객체가 될 수 있다. 
창고는 재고 수량을 자체적으로 조절할 수 있어야 하고, 장바구니는 사용자의 행동에 따라 스스로 물건을 담거나 뺄 수 있어야 한다.

절차지향과 객체지향은 코드 구조에 있어 큰 차이가 있다. 
절차지향 방식에서는 main 함수 등 외부에서 객체의 상태를 가져오고(setter, getter) 직접 조작한다. 
반면, 객체지향은 필요한 정보를 객체에게 넘기고 그 객체가 스스로 처리하게 만든다. 
예를 들어 store.addStock()처럼 행동의 주체를 외부가 아닌 객체 자신으로 설정하는 것이다. 
이 차이는 단순한 예제에서는 크게 느껴지지 않을 수 있지만, 여러 객체가 서로 협력해야 할 때 객체지향이 훨씬 더 구조적이고 유지보수에 유리하다.

예를 들어 소비자가 상품을 구매한다고 하면, 장바구니에 담긴 상품을 창고에서 구매하는 과정에서 창고의 재고는 줄고 소비자의 잔고도 감소해야 한다. 
객체지향적 코드에서는 이를 user.buy(cart, store)처럼 한 줄로 명확하게 표현할 수 있다. 
절차지향 방식처럼 하나하나 명령어로 분해하지 않아도 되고, 의도가 드러나는 코드가 되어 훨씬 직관적이다.

객체지향을 설계할 때 자주 등장하는 개념이 책임, 메시지, 역할이다. 
객체는 외부로부터 메시지를 받아 반응하며, 메시지는 어떤 요청을 담고 있는 것이다. 
예를 들어 “재고를 추가해주세요”라는 요청은 store.addStock(item, quantity)처럼 메시지 형태로 전달된다.
이 메시지를 처리하는 책임이 객체에 있고, 여러 책임이 모이면 하나의 역할을 구성한다. 
창고 객체는 재고 추가, 제거, 확인 등의 책임을 지니고 있으므로 '창고'라는 역할을 수행하게 되는 것이다.

객체를 설계할 땐 먼저 기능(메시지)을 생각하고, 이 기능을 누가 책임질지 정한 후 관련 책임들을 묶어 역할로 만들고, 그 역할을 맡을 객체를 구현하는 순서로 진행된다. 
중요한 것은 데이터 중심이 아닌 기능 중심으로 설계를 해야 한다는 것이다. 
예를 들어 User 클래스를 만들 때 이름이나 이메일 같은 속성부터 생각하면 데이터 중심이 되기 쉽다. 
반대로 “User는 어떤 행동을 해야 하지?”처럼 기능과 메시지를 먼저 고민하고, 그 기능에 필요한 데이터가 무엇인지 역으로 추론하는 방식이 객체지향 설계에 더 적합하다.

객체지향은 결국 스스로 행동하고, 다른 객체와 협력하며, 각자의 책임을 분명히 하는 구조를 만드는 것이다. 
결과적으로 이런 구조는 의도를 잘 드러내고, 유연하고 유지보수하기 쉬운 코드를 만들어준다.
