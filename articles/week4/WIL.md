이번 미션코스 4주차에서는 추가기능 구현과 리팩토링을 과제로 하였다.
리팩토링을 하는 과정에서 공부한 내용들이 좀 있다.
첫번째로는 "Lombok의 @Setter는 왜 지양해야 할까?"라는 내용이다.

검색을 해보니 많은 글에서 @Setter는 가급적 사용을 지양하라고 권장하고 있는 걸 확인했다.
@Getter, @NoArgsConstructor 같은 어노테이션은 정말 유용하게 쓰고 있는데,
유독 @Setter만큼은 여러 자료에서 "지양하라"고 강조하고 있어서 그 이유를 조금 더 파봤다.

일단 @Setter는 클래스의 필드에 대한 setter 메서드를 자동으로 생성해주는 어노테이션이다.
그럼 굉장히 편리한데 왜 지양하라고 할까?
가장 우선적인 문제는 무분별하게 남용될 경우
객체의 상태가 어디서든 변경될 수 있는 구조가 되어버린다는 것이다.
좀 과장을 하면 전역변수를 쓰는거와 큰 차이가 없는 것이다.

두번째로는 저번에 공부했었던 SOLID원칙에서 찾을 수 있는데,
SPR -> 단일 책임 원칙을 깬다는 것이다.
@Sette를 써서 객체 내부의 상태를 외부에서 마음대로 바꿀 수 있게 허용하면,
"객체 스스로 자신의 상태를 관리하는 책임"이 사라지게 되어 객체지향적이지 못하게 되는 것이다.

그래서 내 코드를 다시 살펴봤다.
작성했던 부분 두 군데에서 @Setter가 사용되고 있었고,
특히 하나는 상태 변경이 의도치 않게 여러 레이어에서 일어나고 있다는 걸 발견했다.
결국 이 부분은 setter를 걷어내고, 명시적인 메서드를 따로 정의하는 방식으로 리팩토링했다.

이렇게 바꾸고 나니까 객체가 스스로의 상태를 관리하도록 할 수 있었고,
불필요한 외부 접근도 막을 수 있어서 코드의 안정성과 의도 전달력이 훨씬 좋아졌다.

그리고 이번 과제를 하면서 또 하나 적용해본 게 바로 stream 문법이었다.
사실 기존에는 for 문을 써서 반복 처리하던 부분이 많았는데,
stream을 활용하였더니 데이터를 가공하는 과정이 훨씬 명시적으로 보이고, 읽기도 편해졌다.

중간에 어떤 연산을 추가하거나 변경할 때도
코드 구조를 바꾸지 않고 그대로 이어붙일 수 있어서,
확장성과 유지보수 측면에서도 장점이 크다고한다.(아직은 잘 모르겟다)

처음엔 문법이 살짝 어색했지만, 직접 적용해보니 왜 많은 사람들이 stream을 선호하는지 알 것 같았다.
앞으로는 반복문을 쓸 일이 생기면
for문보다 먼저 stream으로 풀어볼 수 있을지부터 고민해봐야겠다는 생각을 했다.

