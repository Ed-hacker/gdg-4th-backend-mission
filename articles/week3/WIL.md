JavaDocs & Swagger 정리
프로젝트를 진행하다 보면, 
다른 사람이 내 코드를 쉽게 이해할 수 있도록 주석을 잘 써두고 
documents를 잘 만들어두는게 진짜 중요하다고 느낀다.
이런 문서화를 도와주는 대표적인 도구 중 하나가 JavaDoc, 그리고 API 문서 자동화에 유용한 Swagger다.
이 두 가지에 대해 정리해보려고 한다.
​
JavaDocs란?
JavaDoc 주석은 코드 요소(예: 클래스, 메소드, 필드)에 대한 설명을 작성할 수 있게 도와주는 
특수한 주석 문법이다.
보통은 메소드나 클래스 바로 위에 /**로 시작해서 */로 끝나는 형식으로 작성한다.
이 주석은 그냥 글 써두는 게 아니라, Java에서 제공하는 javadoc 도구를 통해 HTML 문서로 변환할 수 있다.
덕분에 프로젝트 전반에 대한 API 참조 문서를 손쉽게 만들 수 있다.
​
형식은 이렇게 생겼다
/**로 시작해서 */로 끝남
@로 시작하는 태그를 통해 의미를 명확히 구분함
예: @param, @return, @throws 등
​
IntelliJ에서는 메소드 위에 /** 치고 Enter를 누르면 자동으로 JavaDoc 양식을 만들어준다.
이렇게 하면 양식을 따로 외워두지 않아도 되고, 작성도 편하다.
작성된 JavaDoc은 메소드에 마우스를 올리거나 호출할 때 힌트로 보여주기 때문에
메소드 정의를 굳이 찾아보지 않아도 된다. 이게 생각보다 꽤 유용하다.

​
Swagger란?
Swagger는 API 문서를 자동으로 생성해주는 프레임워크다.
Spring Boot 프로젝트에서 특히 많이 사용되는데,
내가 만든 REST API의 동작 방식과 파라미터, 응답 구조 등을 시각적으로 보여주는 웹 문서를 만들어준다.
Swagger UI를 통해 웹 페이지에서 직접 테스트도 가능하고,
API 설명도 잘 정리되어 있어서 
프론트엔드와 벡엔드가 협업할 때나 
테스트할 때 유용하다.
​
기본적인 설정 단계는 아래와 같이 이루어져 있다.
springdoc-openapi 혹은 swagger-springfox 라이브러리를 프로젝트에 추가
Controller의 각 API 메소드 위에 설명 애노테이션을 추가
서버를 띄운 후 http://localhost:8080/swagger-ui/index.html 주소로 들어가서 문서 확인
​
나는 추가적으로 Swagger 설정을 좀 더 명확하게 해주기 위해 SwaggerConfig라는 클래스를 따로 만들었다.
우선 Spring Boot 3.x 버전부터는 Swagger/OpenAPI 설정을 명시적으로 해주는 게 좋다고 하고,
이 클래스에서 API 문서의 제목, 설명, 버전 같은 기본 정보를 설정해줄 수 있기 떄문이다.
내가 기본 정보를 수정할 수 있기 때문에 보는 사람 입장에서 정보들을 다시 쓸 수 있다,.
​
http://localhost:8080/swagger-ui/index.html  로 들어가면 
화면이 나오는 것을 확인할 수 있다.
각 method들을 클릭하면 해당되는 동작 방식과 파라미터, 응답 구조 등을 시각적으로 보여준다!
 
코드를 잘 짜는 것도 중요하지만, 
다른 사람이 잘 이해할 수 있게 문서화하는 것 역시 그만큼 중요하다는 걸 요즘 느끼고 있다.
JavaDoc이랑 Swagger는 그걸 도와주는 기본 도구들이니까 꼭 익숙해져두면 좋다.
특히 Swagger는 단순히 자동화만 믿기보다는
조금만 신경 써서 설정을 정리해두면 좋은 코드 습관을 익혀야겠다고 생각했다.



ORM과 영속성 컨텍스트 정리
사실 이 내용은 저번 방학 때 김영한님의 JPA 강의를 들으면서 한 번 공부하고, 
그때 따로 정리도 해뒀던 부분이다.
그런데 이번에 다시 과제로 나와 예전에 봤던 정리글을 다시 봐보고, 
해당하는 부분의 강의도 다시 돌려보면서 복습하는 시간을 가졌다.
처음 배우는 내용은 아니지만, 확실히 시간이 지나니까 어설프게 알고 있던 개념들이 있었고,
이번 기회에 더 단단하게 정리하는 계기가 됐다.
​
ORM(Object-Relational Mapping)
ORM은 자바 객체와 데이터베이스 테이블을 1:1로 매핑해서, 
자바 코드만으로도 데이터베이스 작업을 할 수 있게 도와주는 것이다.
​
ORM은 특정 프레임워크나 라이브러리 이름이 아니라 개념이다.
JPA가 대표적인 ORM 구현체 중 하나라고 보면 된다.
​
우리가 흔히 사용하는 @Entity, @Id, @Repository 같은 어노테이션들,
그리고 findById(), save() 같은 메소드들이 전부 이 ORM 구조 위에서 동작하는 것들이다.
​
예를 들어 Item이라는 테이블이 있다면, 
자바에서는 Item이라는 객체를 만들어서 필드 하나하나가 컬럼과 매칭되도록 한다.
그 상태에서 itemRepository.save(item) 같은 코드만 작성하면,
INSERT 쿼리가 자동으로 만들어져서 실행되는 식이다.
​
이 방식의 장점은 분명하다.
SQL을 일일이 작성하지 않아도 되니까 개발 속도가 빨라지고,
필드 하나 바꾸는 것만으로도 전체 흐름이 자연스럽게 바뀐다.
그렇기 때문에 유지보수도 편하고, 코드 자체도 더 객체지향적으로 설계할 수 있다.
​
특히 프로젝트 초반에는 ORM 덕분에 훨씬 빠르게 개발을 진행할 수 있다.
하지만 단점도 분명히 존재한다.
복잡한 쿼리나 대량의 데이터 처리처럼 성능이 중요한 구간에서는,
자동으로 생성되는 쿼리를 신뢰하기 어렵고, 결국 SQL을 직접 작성해야 할 때도 많다.
그래서 보통은 기본적인 CRUD는 ORM으로 처리하고,
조금 더 세밀한 제어가 필요한 부분은 JPQL이나 네이티브 SQL로 커버하는 방식으로 많이들 개발한다고 한다.
(나는 아직 JPA로만 했었다;; 세밀한 제어가 필요 없엇나보다...)
​
​
영속성 컨텍스트 (Persistence Context)
이번에 다시 강의를 들으면서 가장 크게 리마인드된 개념이 바로 영속성 컨텍스트였다.
예전에 이 강의를 듣기 전에 JPA를 쓸 때에는 .persist()만 기억하고,
“이걸 호출하면 DB에 저장되는구나” 정도로만 이해하고 있었는데,
사실 persist()는 DB에 바로 저장하는 게 아니라 
영속성 컨텍스트라는 공간에 엔티티를 먼저 저장하는 작업이라는 걸 다시 상기하게 됐다.
​
영속성 컨텍스트는 일종의 1차 캐시처럼 동작한다.
같은 트랜잭션 안에서 같은 엔티티를 여러 번 조회하면, DB에서 다시 꺼내지 않고 캐시된 값을 반환해준다.

영속 컨텍스트 구조
위의 구조처럼 되어있는데 find("member2")를 통해 member2를 찾으면 1차캐시에서 먼저 찾는다
그 후에 있으면 바로 해당 엔티티를 반환하고 없으면 위처럼 DB를 조회한다
DB에 있으면 1차 캐시에 저장을 해서 반환을 하는 구조이다,
​

동일성 보장
그리고 같은 트랜잭션 안에서 같은 엔티티를 여러 번 조회하면,
DB에서 다시 꺼내지 않고 캐시된 값을 반환해준다.
그래서 em.find()로 두 번 조회한 객체를 ==로 비교해도 true가 나오는데
이게 바로 “동일성 보장”이라는 개념이다.
​
처음 배울 땐 이런 내용들이 머릿속에 흐릿하게만 있었는데,
그 때보다 그래도 코드를 많이 쳐보고 이해해봤나보다
이번에 다시 보면서 훨씬 구체적인 동작 원리를 이해할 수 있었다.
​
또 하나 중요한 건 변경감지(Dirty Checking)이다.
영속 상태의 객체에서 필드 값을 바꾸기만 하면,
커밋 시점에 JPA가 알아서 UPDATE 쿼리를 만들어준다는 것.
개발자가 직접 update() 같은 메서드를 호출하지 않아도 된다는 점이 굉장히 편리하다.
예전엔 이게 되게 마법 같다고 느꼈는데, 
다시 보니까 내부적으로는 변경된 필드를 감지해서 SQL을 만들어내는 방식이더라.
이런 구조가 있기에, JPA는 실무에서 생산성과 유지보수성을 모두 챙길 수 있는 도구라는 생각이 다시 들었다.
​
다시 정리하면서 느낀 점
처음엔 “아 이거 다 배운 거니까 금방 쓰겠지” 싶었는데 막상 정리를 시작하니까 내가 제대로 알고 있는 부분과
기억이 가물가물한 부분이 확실히 갈렸다.
예전에 썼던 정리노트를 보면서 "아 이게 그거였지" 하고 기억이 나는 것도 있었고,
그땐 그냥 외워뒀던 개념이 이제는 조금 더 ‘왜 이렇게 설계됐는지’까지 이해되는 것도 있었다.
특히 영속성 컨텍스트의 역할, JPA가 어떻게 트랜잭션 커밋 시점까지 쿼리를 모았다가 처리하는지,
1차 캐시와 Dirty Checking 같은 것들이 다시 정리되니까 JPA 전체 구조가 좀 더 명확하게 그려졌다.
ORM이 단순히 “SQL 안 써도 되는 편리한 도구”가 아니라,
객체 지향 프로그래밍과 관계형 DB 사이의 간극을 메꾸기 위한 철학적인 시도라는 것도 다시 한 번 느낄 수 있었다.
​
